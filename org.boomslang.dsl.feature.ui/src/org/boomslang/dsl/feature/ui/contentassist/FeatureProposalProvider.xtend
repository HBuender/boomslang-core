/*
 * generated by Xtext
 */
package org.boomslang.dsl.feature.ui.contentassist

import com.google.inject.Inject
import com.wireframesketcher.model.ClickSupport
import com.wireframesketcher.model.Screen
import com.wireframesketcher.model.SelectionSupport
import com.wireframesketcher.model.TextInputSupport
import java.util.List
import org.boomslang.core.contentassist.CoreProposalProvider
import org.boomslang.dsl.feature.feature.BBooleanPropertyAssertion
import org.boomslang.dsl.feature.feature.BComponent
import org.boomslang.dsl.feature.feature.BScenario
import org.boomslang.dsl.feature.feature.BTabAssertion
import org.boomslang.dsl.feature.feature.BToScreenSwitch
import org.boomslang.dsl.feature.services.BWidgetUtil
import org.boomslang.dsl.feature.services.FeatureGrammarAccess
import org.boomslang.dsl.feature.services.WidgetTypeRefUtil
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.CrossReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.GrammarUtil
import org.eclipse.xtext.Group
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.naming.IQualifiedNameConverter
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor

import static org.boomslang.dsl.feature.feature.FeaturePackage.Literals.*

import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * see http://www.eclipse.org/Xtext/documentation.html#contentAssist on how to customize content assistant
 */
class FeatureProposalProvider extends AbstractFeatureProposalProvider {

	@Inject extension WidgetTypeRefUtil

	@Inject extension FeatureGrammarAccess

	@Inject extension IQualifiedNameProvider

	@Inject IQualifiedNameConverter qualifiedNameConverter

	@Inject extension BWidgetUtil

	@Inject ImportReplacementTextApplier importReplacementTextApplier

	@Inject extension CoreProposalProvider

	override completeBBooleanPropertyAssertion_BooleanPropertyName(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		switch (model) {
			BBooleanPropertyAssertion: {
				for (suggestion : model.assertionWidgetWrapper.widget.namesOfBooleanAttributes) {
					acceptor.accept(createCompletionProposal(suggestion, suggestion, null, context))
				}
			}
		}
	}

	override completeBTabAssertion_BooleanPropertyName(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		switch (model) {
			BTabAssertion: {
				for (suggestion : model.BTabItemWrapper.tabItem.namesOfBooleanAttributes) {
					acceptor.accept(createCompletionProposal(suggestion, suggestion, null, context))
				}
			}
		}
	}

	override completeBStringOrParam_Text(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal('""', '""', null, context))
	}

	override completeBStringOrParam_Param(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		suggestParentScenarioParamNames(model, context, acceptor)
	}

	override complete_BIntOrStringOrParam(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
	}

	override completeBIntOrStringOrParam_Text(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal('""', '""', null, context))
	}

	override completeBIntOrStringOrParam_Int(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal('1', '1', null, context))
	}

	override completeBIntOrStringOrParam_Param(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		suggestParentScenarioParamNames(model, context, acceptor)
	}

	def suggestParentScenarioParamNames(EObject model, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		switch (bScenarioParent : EcoreUtil2.getContainerOfType(model, BScenario)) {
			BScenario: {
				for (param : bScenarioParent.params) {
					val suggestion = '@' + param.name
					acceptor.accept(createCompletionProposal(suggestion, suggestion, null, context))
				}
			}
		}
	}

	override complete_AtParam(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		atParamAccess.group.createKeywordProposal(context, acceptor, false)
	}

	override complete_AtDataProvider(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		atDataProviderAccess.group.createKeywordProposal(context, acceptor, false)
	}

	override complete_AsA(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		asAAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_IwantTo(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		iwantToAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_InOrderTo(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		inOrderToAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_GivenIamOnThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		givenIamOnTheAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_AndI(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		andIAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_WhenI(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		whenIAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_ThenIAmOnThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		thenIAmOnTheAccess.group.createKeywordProposal(context, acceptor)

	}

	override complete_AndThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		andTheAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_ClickThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		clickTheAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_IntoThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		intoTheAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_ThenThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		thenTheAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_IClick(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		switch (model) {
			BComponent: {
				if (model.widget.widget instanceof ClickSupport) {
					IClickAccess.group.createKeywordProposal(context, acceptor)
				}
			}
		}
	}

	override complete_ISelect(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		switch (model) {
			BComponent: {
				if (model.widget.widget instanceof SelectionSupport) {
					ISelectAccess.group.createKeywordProposal(context, acceptor)
				}
			}
		}
	}

	override complete_IType(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		switch (model) {
			BComponent: {
				if (model.widget.widget instanceof TextInputSupport) {
					ITypeAccess.group.createKeywordProposal(context, acceptor)
				}
			}
		}
	}

	override complete_DoubleClick(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		doubleClickAccess.group.createKeywordProposal(context, acceptor)

	}

	override complete_DoubleClickIt(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		doubleClickItAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_InColumn(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		inColumnAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_FromThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		fromTheAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_CellInRow(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		cellInRowAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_AndColumn(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		andColumnAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_SelectThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		selectTheAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_SelectTheEntry(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		selectTheEntryAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_AndPress(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		andPressAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_ActivateTheNode(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		activateTheNodeAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_ActivateTheCell(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		activateTheCellAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_AtPath(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		atPathAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_HasChildren(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		hasChildrenAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_IsDecoratedWith(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		isDecoratedWithAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_ActivateTheArea(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		activateTheAreaAccess.group.createKeywordProposal(context, acceptor)
	}

	override completeBTreeAssertion_ImageName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("\"\" image", "image", null, context))
	}

	override complete_Header(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("header from the ", "header", null, context))
	}

	override complete_Contains(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("contains", context))
	}

	override completeBWidgetWrapper_Widget(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeProposal(model, assignment, context, acceptor)
	}

	override completeBWidgetWrapper_WidgetType(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeNameProposal(model, assignment, context, acceptor, BWIDGET_WRAPPER__WIDGET)
	}

	override completeBTreeWrapper_Tree(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeProposal(model, assignment, context, acceptor)
	}

	override completeBTreeWrapper_TreeType(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeNameProposal(model, assignment, context, acceptor, BTREE_WRAPPER__TREE)
	}

	override completeBToScreenSwitch_Screen(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeProposal(model, assignment, context, acceptor)
	}

	override completeBTableWrapper_Table(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeProposal(model, assignment, context, acceptor)
	}

	override completeBTabItemWrapper_TabItem(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeProposal(model, assignment, context, acceptor)
	}

	override completeBComboWrapper_List(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeProposal(model, assignment, context, acceptor)
	}

	override completeBTabbedPaneWrapper_TabbedPane(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeProposal(model, assignment, context, acceptor)
	}

	override completeBAccordionWrapper_Accordion(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeProposal(model, assignment, context, acceptor)
	}

	/**
	 * create a proposal for the reference to a wireframe widget
	 * (with the type name redundantly appended, as per the requirements of the DSL)
	 * The proposal is based on the offset of the cursor so that the available proposals within a Scenario
	 * depend on the offset of the cursor and the statements specified before. 
	 * Example:
	 * <br><pre>
	 * <br>Scenario "Open  Editor"
	 * <br>Given I am on the Explorer screen
	 * <br>
	 * <br>   when I double click "Product" in column 1 from the Explorer table
	 * <br> 
	 * <br>   then I am on the ProductEditor screen
	 * </pre>
	 * <br>
	 * The example shows a typical feature statement in which the actual type proposal depends on the cursor offset.
	 * If the cursor is at a position before the line "then I am on the..." all widgets types available on the Explorer screen
	 * should be proposed. If the cursor is behind that line all widget types from the ProductEditor screen should be proposed
	 * since there was a change of the screen context before. 
	 */
	def createTypeProposal(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		// Definition of variables for getting the initial scope and Qualified Name
		val widgetTypeERef = GrammarUtil.getReference(assignment.getTerminal() as CrossReference)
		val List<QualifiedName> prefixQNames = model.getPrefixQName(context)
		val IScope scope = model.getScope(widgetTypeERef, context)
		// Filtering the scope to only propose widget types valid in the current context
		for (IEObjectDescription description : scope.allElements) {
			val qname = description.qualifiedName
			val String typeName = if ('item'.equals(description.EClass.name.toLowerCase)) {
					'tab'
				} else {
					description.EClass.name.toLowerCase
				}
			if (!(!prefixQNames.nullOrEmpty && !qname.qNameInPrefixNames(prefixQNames) && !typeName.equals("screen"))) {
				val displayString = qualifiedNameConverter.toString(qname.skipFirst(qname.segmentCount - 1))
				val proposal = (createCompletionProposal(displayString + " " + typeName, displayString + " " + typeName,
					null, context) as ConfigurableCompletionProposal)
				proposal.setAdditionalData(ImportReplacementTextApplier::ADDITIONAL_DATA_QNAME, qname)
				proposal.setAdditionalProposalInfo(typeName)
				proposal.setTextApplier(importReplacementTextApplier)
				acceptor.accept(proposal)
			}
		}
	}

	def qNameInPrefixNames(QualifiedName qname, List<QualifiedName> prefixNames) {
		prefixNames.filter[qname.startsWith(it)].size > 0
	}

	/**
	 * Return the Scope for the nearest Screen based on the offset of the cursor
	 */
	def getScope(EObject model, EReference widgetTypeERef, ContentAssistContext context) {
		val screenBeforeOffset = model.getScreenBeforeOffset(context)
		if (model.isSingleScreenSwitch || screenBeforeOffset == null) {
			scopeProvider.getScope(model, widgetTypeERef)
		} else {
			scopeProvider.getScope(screenBeforeOffset, widgetTypeERef)
		}
	}

	/**
	 * Return the Qualified Name of the nearest Screen based on the offset of the cursor
	 */
	def getPrefixQName(EObject model, ContentAssistContext context) {
		// Based on the available screen switches within the scenario the scope is determined.
		val retList = newArrayList
		val screenBeforeOffset = model.getScreenBeforeOffset(context)
		if (model.isSingleScreenSwitch || screenBeforeOffset == null) {
			model.widgetContainerOfNearestContext?.forEach[retList.add(it.fullyQualifiedName)]
		} else {
			screenBeforeOffset.allReferencedScreens.forEach[retList.add(it.fullyQualifiedName)]
		}
		return retList
	}

	/**
	 * True if there are more than one BToScreeSwitch objects in the scenario
	 */
	def isSingleScreenSwitch(EObject model) {
		if (model.getAllContentsOfType(BToScreenSwitch) == null) {
			false
		} else {
			model.getAllContentsOfType(BToScreenSwitch).size < 2
		}
	}

	/**
	 * Returns the last Screen referenced before the offset of the context
	 */
	def getScreenBeforeOffset(EObject model, ContentAssistContext context) {
		var Screen screen = null
		for (BToScreenSwitch screenSwitch : model.getAllContentsOfType(BToScreenSwitch)) {
			if (screenSwitch.screen != null && context.offset > NodeModelUtils.getNode(screenSwitch).offset) {
				screen = screenSwitch.screen
			}
		}
		return screen
	}

	/**
	 * create a proposal for the name of a type (DSL has requirements for 
	 * redundant type name mentioning of referenced wireframe widgets) 
	 * 
	 * @param widgetReference - the EReference to the widget, this will be used on the 
	 * given {@code model} to compute the type name suggestion
	 */
	def createTypeNameProposal(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor, EReference widgetReference) {
		val suggestedName = model.getReferencedNameSupportTypeName(widgetReference)
		if (suggestedName != null) {
			acceptor.accept(createCompletionProposal(suggestedName, context))
		}
	}

	/** 
	 * For a given group, filters the keywords and joins them.
	 * @param group the group to use for the proposal, example: 
	 * myGrammarRuleAccess.getGroup()
	 * 
	 * @param withSpaceBetweenWords - set this to true if the keywords should be joined 
	 * with a 'space'as separator, otherwise they will be just concatenated
	 * 
	 * @return the proposal, example: "I want to" for the grammar rule
	 * 
	 * MyGrammarDatatypeRule:
	 * 'I' 'want' 'to'
	 */
	def createKeywordProposal(Group group, ContentAssistContext context, ICompletionProposalAcceptor acceptor,
		boolean withSpaceBetweenWords) {
		if (group == null) {
			return null
		}
		val joinChar = if (withSpaceBetweenWords) {
				" "
			} else {
				""
			}
		val proposalString = group.elements.filter(Keyword).map[value].join(joinChar) + " "
		acceptor.accept(createCompletionProposal(proposalString, proposalString, null, context))
	}

	def createKeywordProposal(Group group, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createKeywordProposal(group, context, acceptor, true)
	}

	override completeBFeaturePackage_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val packageName = model.completeBPackage_Name()
		acceptor.accept(createCompletionProposal(packageName, packageName, null, context))

	}

}
