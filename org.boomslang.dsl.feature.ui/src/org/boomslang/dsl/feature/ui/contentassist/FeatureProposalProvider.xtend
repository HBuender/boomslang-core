/*
 * generated by Xtext
 */
package org.boomslang.dsl.feature.ui.contentassist

import com.google.inject.Inject
import com.wireframesketcher.model.Screen
import com.wireframesketcher.model.Table
import java.util.List
import org.boomslang.core.contentassist.CoreProposalProvider
import org.boomslang.dsl.feature.feature.BScenario
import org.boomslang.dsl.feature.feature.BToScreenSwitch
import org.boomslang.dsl.feature.services.BActionUtil
import org.boomslang.dsl.feature.services.BWidgetUtil
import org.boomslang.dsl.feature.services.FeatureGrammarAccess
import org.boomslang.dsl.feature.services.WidgetTypeRefUtil
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.CrossReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.GrammarUtil
import org.eclipse.xtext.Group
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.naming.IQualifiedNameConverter
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor

import static org.boomslang.dsl.feature.feature.FeaturePackage.Literals.*

import static extension org.eclipse.xtext.EcoreUtil2.*
import com.wireframesketcher.model.WidgetGroup
import com.wireframesketcher.model.TabbedPane
import com.wireframesketcher.model.Tree
import com.wireframesketcher.model.xtext.ScreenResourceDescriptionStrategyUtil
import com.wireframesketcher.model.xtext.IEObjectDescriptionUtil
import org.boomslang.dsl.feature.feature.NodeQName
import org.eclipse.xtext.scoping.impl.FilteringScope
import org.apache.commons.lang.StringUtils
import org.boomslang.dsl.feature.feature.BTabAssertion
import com.wireframesketcher.model.Accordion
import org.boomslang.dsl.feature.feature.BFeaturePackage

/**
 * see http://www.eclipse.org/Xtext/documentation.html#contentAssist on how to customize content assistant
 */
class FeatureProposalProvider extends AbstractFeatureProposalProvider {

	@Inject extension WidgetTypeRefUtil

	@Inject extension FeatureGrammarAccess

	@Inject extension IQualifiedNameProvider

	@Inject IQualifiedNameConverter qualifiedNameConverter

	@Inject extension BWidgetUtil
	
	@Inject extension BActionUtil

	@Inject ImportReplacementTextApplier importReplacementTextApplier

	@Inject extension CoreProposalProvider
	
	@Inject extension IEObjectDescriptionUtil 
	
	@Inject extension ScreenResourceDescriptionStrategyUtil
	
	override completeBPropertyAssertionAction_PropertyName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
			for (suggestion : model.widgetBeforeOffset.namesOfProperties){
				acceptor.accept(createCompletionProposal(suggestion, suggestion, null, context))
			}
	}
	
	override completeBBooleanAssertionAction_BooleanPropertyName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
			for (suggestion : model.widgetBeforeOffset.namesOfBooleanAttributes){
				acceptor.accept(createCompletionProposal(suggestion, suggestion, null, context))
			}
	}

	// attila: TODO
//    override completeBTabAssertion_BooleanPropertyName(EObject model, Assignment assignment,
//        ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//        switch (model) {
//            BTabAssertion: {
//                for (suggestion : model.BTabItemWrapper.tabItem.namesOfBooleanAttributes) {
//                    acceptor.accept(createCompletionProposal(suggestion, suggestion, null, context))
//                }
//            }
//        }
//    }

	override completeBStringOrParam_Text(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal('""', '""', null, context))
	}

	override completeBStringOrParam_Param(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		suggestParentScenarioParamNames(model, context, acceptor)
	}

	override complete_BIntOrStringOrParam(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
	}

	override completeBIntOrStringOrParam_Text(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal('""', '""', null, context))
	}

	override completeBIntOrStringOrParam_Int(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal('1', '1', null, context))
	}

	override completeBIntOrStringOrParam_Param(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		suggestParentScenarioParamNames(model, context, acceptor)
	}

	def suggestParentScenarioParamNames(EObject model, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		switch (bScenarioParent : EcoreUtil2.getContainerOfType(model, BScenario)) {
			BScenario: {
				for (param : bScenarioParent.params) {
					val suggestion = '@' + param.name
					acceptor.accept(createCompletionProposal(suggestion, suggestion, null, context))
				}
			}
		}
	}

	override complete_AtParam(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		atParamAccess.group.createKeywordProposal(context, acceptor, false)
	}

	override complete_AtDataProvider(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		atDataProviderAccess.group.createKeywordProposal(context, acceptor, false)
	}

	override complete_AsA(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		asAAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_IwantTo(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		iwantToAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_InOrderTo(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		inOrderToAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_GivenIamOnThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		givenIamOnTheAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_OnScreen(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("screen ", "screen", null, context))
	}
	
	override complete_OnTab(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("tab ", "tab", null, context))
	}
	
	override complete_AndI(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		andIAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_WhenI(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		whenIAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_ThenIAmOnThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		thenIAmOnTheAccess.group.createKeywordProposal(context, acceptor)

	}

	override complete_AndThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		andTheAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_ThenThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		thenTheAccess.group.createKeywordProposal(context, acceptor)
	}
	
	override complete_CellWhere(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if(model.widgetBeforeOffset instanceof Table){
			cellWhereAccess.group.createKeywordProposal(context, acceptor)
		}
	}
	
	override complete_ISelectThe(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		if(model.widgetBeforeOffset instanceof TabbedPane){
			ISelectTheAccess.group.createKeywordProposal(context, acceptor)
		}
	}
	
	override complete_IActivateTheNode(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		if(model.widgetBeforeOffset instanceof Tree) {
			IActivateTheNodeAccess.group.createKeywordProposal(context, acceptor)
		}
	}
	
	override complete_Where(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		if(model.widgetBeforeOffset instanceof WidgetGroup){
			acceptor.accept(createCompletionProposal("where ", "where", null, context))
		}		
	}

	override complete_InThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		inTheAccess.group.createKeywordProposal(context, acceptor)
	}
	
	override complete_IDoubleClick(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if(model.contextOfDoubleClickableWidget){
			IDoubleClickAccess.group.createKeywordProposal(context, acceptor)
			}
	}
	
	override complete_ICheck(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if(model.isContextOfCCheckableWidget){
			ICheckAccess.group.createKeywordProposal(context, acceptor)
		
		}
	}
	override complete_SelectedEntry(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if(model.isContextOfSelectableWidget){
		 	selectedEntryAccess.group.createKeywordProposal(context, acceptor)	
		}
	}

	override complete_SelectedTabIs(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		if(model.widgetBeforeOffset instanceof TabbedPane){
			selectedTabIsAccess.group.createKeywordProposal(context, acceptor)
		}
	}
	
	override complete_Row(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("row ", "row", null, context))
	}
	
	override complete_Column(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("column ", "column", null, context))
	}
	
	override complete_Property(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("property ", "property", null, context))
	}
	
	
	override complete_BCompareOperator(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("equals ", "equals", null, context))
		acceptor.accept(createCompletionProposal("not equals ", "not equals", null, context))
		acceptor.accept(createCompletionProposal("matches ", "matches", null, context))
		acceptor.accept(createCompletionProposal("contains ", "contains", null, context))
		if(model.isContextOfSelectableWidget){
			acceptor.accept(createCompletionProposal("index equals ", "index equals", null, context))
		}
	}	

	override complete_IClick(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if (model.isContextOfClickableWidget) {
			IClickAccess.group.createKeywordProposal(context, acceptor)
		}
	}
		

	override complete_ISelect(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if (model.isContextOfSelectableWidget) {
			ISelectAccess.group.createKeywordProposal(context, acceptor)
		}
	}

	override complete_IType(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if (model.isContextOfTypeableWidget) {
			ITypeAccess.group.createKeywordProposal(context, acceptor)
		}
	}


	override complete_FromThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		fromTheAccess.group.createKeywordProposal(context, acceptor)
	}

	
	override complete_Equals(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("equals ", "equals", null, context))
	}
	
	override complete_NotEquals(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		notEqualsAccess.group.createKeywordProposal(context, acceptor)
	}

	override complete_Contains(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if(model.isAssertionActionContext){
			acceptor.accept(createCompletionProposal("contains", context))
		}
	}
	
	override complete_Is(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("is ", "is", null, context))
	}
	override complete_Not(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("not ", "not", null, context))
	}
	override complete_Matches(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal("matches ", "matches", null, context))
	}

    override completeBTabItemWrapper_TabItem(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTabItemProposal(model, assignment, context, acceptor)
    }
    
	override completeBWidgetWrapper_Widget(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeProposal(model, assignment, context, acceptor)
	}

	override completeBWidgetWrapper_WidgetType(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeNameProposal(model, assignment, context, acceptor, BWIDGET_WRAPPER__WIDGET)
	}


	override completeBToScreenSwitch_Screen(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		createTypeProposal(model, assignment, context, acceptor)
	}
	
	override completeBToScreenSwitch_ComponentScreen(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createTypeProposal(model, assignment, context, acceptor)		
	}
	
    override complete_FinallyICloseIt(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		finallyICloseItAccess.group.createKeywordProposal(context, acceptor)
	}
	

	/**
	 * create a proposal for the reference to a wireframe widget
	 * (with the type name redundantly appended, as per the requirements of the DSL)
	 * The proposal is based on the offset of the cursor so that the available proposals within a Scenario
	 * depend on the offset of the cursor and the statements specified before. 
	 * Example:
	 * <br><pre>
	 * <br>Scenario "Open  Editor"
	 * <br>Given I am on the Explorer screen
	 * <br>
	 * <br>   when I double click "Product" in column 1 from the Explorer table
	 * <br> 
	 * <br>   then I am on the ProductEditor screen
	 * </pre>
	 * <br>
	 * The example shows a typical feature statement in which the actual type proposal depends on the cursor offset.
	 * If the cursor is at a position before the line "then I am on the..." all widgets types available on the Explorer screen
	 * should be proposed. If the cursor is behind that line all widget types from the ProductEditor screen should be proposed
	 * since there was a change of the screen context before. 
	 */
	def createTypeProposal(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		
		// Definition of variables for getting the initial scope and Qualified Name
		val widgetTypeERef = GrammarUtil.getReference(assignment.getTerminal() as CrossReference)
		
		val List<QualifiedName> prefixQNames =
			if ("componentScreen".equals(widgetTypeERef.name)) {
				emptyList // null
			} else if ("tabbedPane".equals(widgetTypeERef.name) || "tabItem".equals(widgetTypeERef.name)) {
				if (EcoreUtil2.getContainerOfType(model, BScenario).BToScreenSwitch.screen.isComponentPart) {
					newArrayList( // attila: making a list
						EcoreUtil2.getContainerOfType(model, BScenario).BToScreenSwitch.screen?.fullyQualifiedName
					)
				}
			} else if (context.isGivenIAmOnThe) {
				emptyList // null
			} else {
				model.getPrefixQName(context)
			}		
		
		val IScope scope = if (!context.isGivenIAmOnThe) { 
			model.getScope(widgetTypeERef, context)	
		} else {
			new FilteringScope(model.getScope(widgetTypeERef, context),[!isComponent])
		}
		
		// Filtering the scope to only propose widget types valid in the current context
		val scopeAllElements = scope.allElements
		
		for (IEObjectDescription description : scopeAllElements) {
			val qname = description.qualifiedName
			val String typeName = if (description.isComponent && "componentScreen".equals(widgetTypeERef.name)) {
					'::'
				} else {
					description.EClass.name.toLowerCase
				}

			if (!(!prefixQNames.nullOrEmpty && !qname.qNameInPrefixNames(prefixQNames) && !typeName.equals("screen"))) {

				val simpleName = qualifiedNameConverter.toString(qname.skipFirst(qname.segmentCount - 1))
				val parentQName = qualifiedNameConverter.toString(qname.skipLast(1))
				var proposalString = simpleName + (if (typeName.equals("::")) typeName else if (typeName.equals("screen")) " " else " " + typeName + " ")
				
				val proposal = (createCompletionProposal(proposalString, proposalString + " - " + parentQName,
					null, context) as ConfigurableCompletionProposal)
				proposal.setAdditionalData(ImportReplacementTextApplier::ADDITIONAL_DATA_QNAME, qname)
				proposal.setAdditionalProposalInfo(typeName)
				proposal.setTextApplier(importReplacementTextApplier)
				acceptor.accept(proposal)
			}
		}
	}

	def createTabItemProposal(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val widgetTypeERef = GrammarUtil.getReference(assignment.getTerminal() as CrossReference)
		val IScope scope = model.getScope(widgetTypeERef, context)
		val scopeAllElements = scope.allElements

		for (IEObjectDescription description : scopeAllElements) {
			val proposalName = description.qualifiedName
			val proposal = (createCompletionProposal(proposalName + " tab", proposalName + " tab",
				null, context) as ConfigurableCompletionProposal)
			acceptor.accept(proposal)
		}
	}
	
	def isGivenIAmOnThe(ContentAssistContext context){
		var parent = context.lastCompleteNode?.parent?.grammarElement
		switch(parent){
		RuleCall:{
				return thenIAmOnTheRule.name.equals(parent.getRule().name)
		}}
	}

	def qNameInPrefixNames(QualifiedName qname, List<QualifiedName> prefixNames) {
		prefixNames.filter[it != null && qname.startsWith(it)].size > 0
	}

	/**
	 * Return the Scope for the nearest Screen based on the offset of the cursor
	 */
	def getScope(EObject model, EReference widgetTypeERef, ContentAssistContext context) {
		val screenBeforeOffset = model.getScreenBeforeOffset(context)
		if (model.isSingleScreenSwitch || screenBeforeOffset == null) {
			scopeProvider.getScope(model, widgetTypeERef)
		} else {
			scopeProvider.getScope(screenBeforeOffset, widgetTypeERef)
		}
	}

	/**
	 * Return the Qualified Name of the nearest Screen based on the offset of the cursor
	 */
	def getPrefixQName(EObject model, ContentAssistContext context) {
		// Based on the available screen switches within the scenario the scope is determined.
		val retList = newArrayList
		val screenBeforeOffset = model.getScreenBeforeOffset(context)
		if (model.isSingleScreenSwitch || screenBeforeOffset == null) {
			model.widgetContainerOfNearestContext?.forEach[retList.add(it.fullyQualifiedName)]
		} else {
			screenBeforeOffset.allReferencedScreens.forEach[retList.add(it.fullyQualifiedName)]
		}
		return retList
	}

	/**
	 * True if there is exactly one BToScreeSwitch objects in the scenario
	 */
	def isSingleScreenSwitch(EObject model) {
		if (model.getAllContentsOfType(BToScreenSwitch) == null) {
			false
		} else {
			model.getAllContentsOfType(BToScreenSwitch).size < 2
		}
	}

	/**
	 * Returns the last Screen referenced before the offset of the context
	 */
	def getScreenBeforeOffset(EObject model, ContentAssistContext context) {
		var Screen screen = null
        for (BToScreenSwitch screenSwitch : model.getContainerOfType(BScenario).getAllContentsOfType(BToScreenSwitch)) {
            if (screenSwitch.screen != null && context.offset > NodeModelUtils.getNode(screenSwitch).offset) {
                screen = screenSwitch.screen
            }
        }
        return screen
		
	}

	/**
     * Returns true if the last screen before the offset has a table
     */
    def fromThePossible(EObject model, ContentAssistContext context) {
        switch model {
            BScenario: if(model.getScreenBeforeOffset(context)?.widgets.filter(Table).size > 0 ||
                model.getScreenBeforeOffset(context)?.widgets.filter(Tree).size > 0 ||
                model.getScreenBeforeOffset(context)?.widgets.filter(Accordion).size > 0) return true
        }
    }

    /**
	 * create a proposal for the name of a type (DSL has requirements for 
	 * redundant type name mentioning of referenced wireframe widgets) 
	 * 
	 * @param widgetReference - the EReference to the widget, this will be used on the 
	 * given {@code model} to compute the type name suggestion
	 */
	def createTypeNameProposal(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor, EReference widgetReference) {
		val suggestedName = model.getReferencedNameSupportTypeName(widgetReference)
		if (suggestedName != null) {
			acceptor.accept(createCompletionProposal(suggestedName, context))
		}
	}

	/** 
	 * For a given group, filters the keywords and joins them.
	 * @param group the group to use for the proposal, example: 
	 * myGrammarRuleAccess.getGroup()
	 * 
	 * @param withSpaceBetweenWords - set this to true if the keywords should be joined 
	 * with a 'space'as separator, otherwise they will be just concatenated
	 * 
	 * @return the proposal, example: "I want to" for the grammar rule
	 * 
	 * MyGrammarDatatypeRule:
	 * 'I' 'want' 'to'
	 */
	def createKeywordProposal(Group group, ContentAssistContext context, ICompletionProposalAcceptor acceptor,
		boolean withSpaceBetweenWords) {
		if (group == null) {
			return null
		}
		val joinChar = if (withSpaceBetweenWords) {
				" "
			} else {
				""
			}
		val proposalString = group.elements.filter(Keyword).map[value].join(joinChar) + " "
		acceptor.accept(createCompletionProposal(proposalString, proposalString, null, context))
	}

	def createKeywordProposal(Group group, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		createKeywordProposal(group, context, acceptor, true)
	}

	override completeBFeaturePackage_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val packageName = model.completeBPackage_Name()
		acceptor.accept(createCompletionProposal(packageName, packageName, null, context))

	}

    /**
     * Proposes the root node of a tree widget
     */
    def proposeTreeRoot(String rawProposal, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
        val proposal = if (rawProposal.indexOf("}") > 0) {
                rawProposal.substring(rawProposal.indexOf("}") + 1)
            } else {
                rawProposal
            }
        acceptor.accept(createCompletionProposal('"' + proposal.trim + '"', proposal, null, context))
    }

    /**
     * Propose all treenodes underneath the given path in the tree
     * Consider the following tree where the number of '-' determines the level in the tree.
     * <br>
     * <br>Root A
     * <br>-Node B
     * <br>-Node C
     * <br>--Node D
     * <br>--Node E
     * <br>---Node F
     * <br>--Node G
     * <br>-Node H
     * <br>
     * 
     * <br>If the model is a NodeQName like '"Root A"'  then Node B, C, and H will be proposed
     * <br>If the model is a NodeQName like '"Root A" > "Node C"' then Node D, E, and G will be proposed
     * <br>If the model is a NodeQName like '"Root A" > "Node C > "Node E"' then Node F will be proposed
     * <br>If the model is a NodeQName like '"Root A" > "Node C > "Node E"> "Node F"' then no node will be proposed
     */
    def proposeTreeNode(EObject model, String treeStructure, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        switch (model) {
            NodeQName: {
                val remainingText = newArrayList(treeStructure)
                model.findCurrentPositionInTree(remainingText)
                if (model.segment.size() > 0) {
                    model.proposeChildren(remainingText, context, acceptor)
                }
            }
        }
    }

    /**
     * Based on the path included in the DSL the position in the underlying tree is retrieved.
     * This position is the basis for the context specific proposals
     */
    def findCurrentPositionInTree(NodeQName model, List<String> remainingText) {
        model.segment.forEach [
            val value = if (it.getText != null && !it.getText.equals("")) {
                    it.getText
                } else if (it.param != null && !it.getParam.equals("")) {
                    it.param.name
                } else {
                    it.int
                }
            switch value {
                String: {
                    // Always written at the first position of the array
                    remainingText.add(0,
                        remainingText.get(0).substring(remainingText.get(0).indexOf(value) + value.length + 1))
                }
            }
        ]
    }

    /**
     * Create a proposal for all children of the current Node
     */
    def proposeChildren(NodeQName model, List<String> remainingText, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        var pattern = StringUtils.repeat("-", model.segment.size)
        val wrongpattern = pattern + "-"
        for (String s : remainingText.get(0).split("\\n")) {
            if (s.startsWith(wrongpattern)) {
                // To deep in tree
                println("ignore: " + s)
            } else if (s.startsWith(pattern)) {
                // The one we are looking for
                var proposal = s
                proposal = if (proposal.indexOf("}") > 0) {
                    proposal.substring(proposal.indexOf("}") + 1)
                } else {
                    proposal.substring(proposal.indexOf(pattern) + pattern.length + 1)
                }
                acceptor.accept(createCompletionProposal('"' + proposal.trim + '"', proposal, null, context))
            } else if (pattern.length > 1 && s.startsWith(pattern.substring(0, pattern.length - 1))) {
                // Higher level one, so now we got all children visited
                return
            }
        }
    }

}
