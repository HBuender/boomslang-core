/*
 * generated by Xtext
 */
package org.boomslang.dsl.feature.ui.contentassist

import org.boomslang.core.contentassist.CoreProposalProvider
import org.boomslang.dsl.feature.feature.BAccordionCommand
import org.boomslang.dsl.feature.feature.BBooleanPropertyAssertion
import org.boomslang.dsl.feature.feature.BScenario
import org.boomslang.dsl.feature.feature.BTabAssertion
import org.boomslang.dsl.feature.feature.BToScreenSwitch
import org.boomslang.dsl.feature.feature.BTreeCommand
import org.boomslang.dsl.feature.feature.BTypeCommand
import org.boomslang.dsl.feature.feature.NodeQName
import org.boomslang.dsl.feature.services.BWidgetUtil
import org.boomslang.dsl.feature.services.FeatureGrammarAccess
import org.boomslang.dsl.feature.services.WidgetTypeRefUtil
import com.google.inject.Inject
import com.wireframesketcher.model.Accordion
import com.wireframesketcher.model.Screen
import com.wireframesketcher.model.Table
import com.wireframesketcher.model.Tree
import java.util.List
import org.apache.commons.lang.StringUtils
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.CrossReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.GrammarUtil
import org.eclipse.xtext.Group
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.naming.IQualifiedNameConverter
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor

import static org.boomslang.dsl.feature.feature.FeaturePackage.Literals.*

import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * see http://www.eclipse.org/Xtext/documentation.html#contentAssist on how to customize content assistant
 */
class FeatureProposalProvider extends AbstractFeatureProposalProvider {

    @Inject extension WidgetTypeRefUtil

    @Inject extension FeatureGrammarAccess

    @Inject extension IQualifiedNameProvider

    @Inject IQualifiedNameConverter qualifiedNameConverter

    @Inject extension BWidgetUtil

    @Inject ImportReplacementTextApplier importReplacementTextApplier
    
    @Inject extension CoreProposalProvider
    

     

    override completeBBooleanPropertyAssertion_BooleanPropertyName(EObject model, Assignment assignment,
        ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
        switch (model) {
            BBooleanPropertyAssertion: {
                for (suggestion : model.assertionWidgetWrapper.widget.namesOfBooleanAttributes) {
                    acceptor.accept(createCompletionProposal(suggestion, suggestion, null, context))
                }
            }
        }
    }

    override completeBTabAssertion_BooleanPropertyName(EObject model, Assignment assignment,
        ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
        switch (model) {
            BTabAssertion: {
                for (suggestion : model.BTabItemWrapper.tabItem.namesOfBooleanAttributes) {
                    acceptor.accept(createCompletionProposal(suggestion, suggestion, null, context))
                }
            }
        }
    }

    def complete_BStringOrParam(BTypeCommand model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
    }

    override completeBStringOrParam_Text(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        acceptor.accept(createCompletionProposal('""', '""', null, context))
    }

    override completeBStringOrParam_Param(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        suggestParentScenarioParamNames(model, context, acceptor)
    }

    override complete_BIntOrStringOrParam(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
    }

    override completeBIntOrStringOrParam_Text(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        acceptor.accept(createCompletionProposal('""', '""', null, context))
    }

    override completeBIntOrStringOrParam_Int(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        acceptor.accept(createCompletionProposal('1', '1', null, context))
    }

    override completeBIntOrStringOrParam_Param(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        suggestParentScenarioParamNames(model, context, acceptor)
    }

    override completeBDoubleClickCommand_Value(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        super.completeBDoubleClickCommand_Value(model, assignment, context, acceptor)
        acceptor.accept(createCompletionProposal('""', "Expected Value - String", null, context))

    }

    override completeBDoubleClickCommand_ColumnIndex(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        super.completeBDoubleClickCommand_ColumnIndex(model, assignment, context, acceptor)
        acceptor.accept(createCompletionProposal("", "Column - Number", null, context))
    }

    def suggestParentScenarioParamNames(EObject model, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        switch (bScenarioParent : EcoreUtil2.getContainerOfType(model, BScenario)) {
            BScenario: {
                for (param : bScenarioParent.params) {
                    val suggestion = '@' + param.name
                    acceptor.accept(createCompletionProposal(suggestion, suggestion, null, context))
                }
            }
        }
    }
    
    
        
    override completeNodeQName_Segment(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
        //Root proposal has to be handled separately
        if(model instanceof BTreeCommand) {
            if( model.nodeQName.segment.size<1){
                model.BTreeWrapper.tree.text.split("\n").get(0).proposeTreeRoot(context,acceptor)
            }
        }
        //Handle other proposals
        val container=model.eContainer
        switch (container){
            BTreeCommand:{
               model.proposeTreeNode(container.BTreeWrapper.tree.text,context,acceptor)
            }
            
        }
    }
    
    override completeBAccordionCommand_Row(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
        if(model instanceof BAccordionCommand){
            for (String line : model.BAccordionWrapper.accordion.text.split(("\n"))){
                var suggestion=line.substring(line.lastIndexOf("}")+2)
                acceptor.accept(createCompletionProposal("\""+suggestion+"\"", suggestion, null, context))                
            }
        }
    }


    override complete_AtParam(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        atParamAccess.group.createKeywordProposal(context, acceptor, false)
    }

    override complete_AtDataProvider(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        atDataProviderAccess.group.createKeywordProposal(context, acceptor, false)
    }

    override complete_AsA(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        asAAccess.group.createKeywordProposal(context, acceptor)
    }

    override complete_IwantTo(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        iwantToAccess.group.createKeywordProposal(context, acceptor)
    }

    override complete_InOrderTo(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        inOrderToAccess.group.createKeywordProposal(context, acceptor)
    }

    override complete_GivenIamOnThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        givenIamOnTheAccess.group.createKeywordProposal(context, acceptor)
    }

    override complete_AndI(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        andIAccess.group.createKeywordProposal(context, acceptor)
    }

    override complete_WhenI(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        whenIAccess.group.createKeywordProposal(context, acceptor)
    }

    override complete_ThenIAmOnThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        thenIAmOnTheAccess.group.createKeywordProposal(context, acceptor)

    }

    override complete_AndThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        andTheAccess.group.createKeywordProposal(context, acceptor)
    }

    override complete_ClickThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        clickTheAccess.group.createKeywordProposal(context, acceptor)
    }

    override complete_IntoThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        intoTheAccess.group.createKeywordProposal(context, acceptor)
    }

    override complete_ThenThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        thenTheAccess.group.createKeywordProposal(context, acceptor)
    }

    override complete_DoubleClick(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        if(model.fromThePossible(context)){
            doubleClickAccess.group.createKeywordProposal(context, acceptor)
        }
        
    }
    
    override complete_DoubleClickIt(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        if(model.fromThePossible(context)){
            doubleClickItAccess.group.createKeywordProposal(context, acceptor)
        }
    }

    override complete_InColumn(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        inColumnAccess.group.createKeywordProposal(context, acceptor)
    }

    override complete_FromThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        if(model.fromThePossible(context)){
            fromTheAccess.group.createKeywordProposal(context, acceptor)
        }
    }

    override complete_CellInRow(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        if (!model.checkIfTree(context)) {
            cellInRowAccess.group.createKeywordProposal(context, acceptor)
        }
    }

    override complete_AndColumn(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        andColumnAccess.group.createKeywordProposal(context, acceptor)
    }
    
    override complete_SelectThe(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
            selectTheAccess.group.createKeywordProposal(context, acceptor)
    }
    
    override complete_SelectTheEntry(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
            selectTheEntryAccess.group.createKeywordProposal(context, acceptor)
    }
    
    override complete_AndPress(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
            andPressAccess.group.createKeywordProposal(context, acceptor)
    }
    
    override complete_ActivateTheNode(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
            activateTheNodeAccess.group.createKeywordProposal(context, acceptor)
    }
    
    override complete_ActivateTheCell(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
            activateTheCellAccess.group.createKeywordProposal(context, acceptor)
    }
    
    override complete_AtPath(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
            atPathAccess.group.createKeywordProposal(context, acceptor)
    }
    override complete_HasChildren(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
            hasChildrenAccess.group.createKeywordProposal(context, acceptor)
    }
    
    override complete_IsDecoratedWith(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
            isDecoratedWithAccess.group.createKeywordProposal(context, acceptor)
    }
    
    override complete_ActivateTheArea(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
            activateTheAreaAccess.group.createKeywordProposal(context, acceptor)
    }
    
    
    override completeBTreeAssertion_ImageName(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
            acceptor.accept(createCompletionProposal("\"\" image", "image", null, context))
        }
        
    override complete_Header(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
            if(model.checkIfTree(context))return;
        acceptor.accept(createCompletionProposal("header from the ", "header", null, context))
    }

    override complete_Contains(EObject model, RuleCall ruleCall, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        acceptor.accept(createCompletionProposal("contains", context))
    }

    override completeBClickCommand_ClickSupport(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTypeProposal(model, assignment, context, acceptor)
    }

    override completeBClickCommand_ClickSupportType(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTypeNameProposal(model, assignment, context, acceptor, BCLICK_COMMAND__CLICK_SUPPORT)
    }

    override completeBTypeCommand_TextInputSupport(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTypeProposal(model, assignment, context, acceptor)
    }

    override completeBTypeCommand_TextInputSupportType(EObject model, Assignment assignment,
        ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
        createTypeNameProposal(model, assignment, context, acceptor, BTYPE_COMMAND__TEXT_INPUT_SUPPORT)
    }

    override completeBWidgetWrapper_Widget(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        if(!model.checkIfTree(context)){   
            createTypeProposal(model, assignment, context, acceptor)
        }
    }
    
    //Checks if the previous command is "it" and if that command is refering to a tree.    
    def checkIfTree(EObject model,ContentAssistContext context){
        if("it".equals(context.lastCompleteNode.text)){
            switch (model){
                BScenario:{
                    println("Last Complete Node:"+model.codeStatements.last)
                    switch (model?.codeStatements?.last){
                        BTreeCommand:{
                            return true
                        }
                    }
                }
            }
        }
        return false
    }

    override completeBWidgetWrapper_WidgetType(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTypeNameProposal(model, assignment, context, acceptor, BWIDGET_WRAPPER__WIDGET)
    }

    override completeBTreeWrapper_Tree(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTypeProposal(model, assignment, context, acceptor)
    }

    override completeBTreeWrapper_TreeType(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTypeNameProposal(model, assignment, context, acceptor, BTREE_WRAPPER__TREE)
    }

    override completeBToScreenSwitch_Screen(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTypeProposal(model, assignment, context, acceptor)
    }

    override completeBTableWrapper_Table(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTypeProposal(model, assignment, context, acceptor)
    }

    override completeBTabItemWrapper_TabItem(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTypeProposal(model, assignment, context, acceptor)
    }
    
    override completeBComboWrapper_List(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTypeProposal(model, assignment, context, acceptor)
    }
    
    override completeBTabbedPaneWrapper_TabbedPane(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTypeProposal(model, assignment, context, acceptor)
    }
    
    override completeBAccordionWrapper_Accordion(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        createTypeProposal(model, assignment, context, acceptor)
    }


    /**
     * create a proposal for the reference to a wireframe widget
     * (with the type name redundantly appended, as per the requirements of the DSL)
     * The proposal is based on the offset of the cursor so that the available proposals within a Scenario
     * depend on the offset of the cursor and the statements specified before. 
     * Example:
     * <br><pre>
     * <br>Scenario "Open  Editor"
     * <br>Given I am on the Explorer screen
     * <br>
     * <br>   when I double click "Product" in column 1 from the Explorer table
     * <br> 
     * <br>   then I am on the ProductEditor screen
     * </pre>
     * <br>
     * The example shows a typical feature statement in which the actual type proposal depends on the cursor offset.
     * If the cursor is at a position before the line "then I am on the..." all widgets types available on the Explorer screen
     * should be proposed. If the cursor is behind that line all widget types from the ProductEditor screen should be proposed
     * since there was a change of the screen context before. 
     */
    def createTypeProposal(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        //Definition of variables for getting the initial scope and Qualified Name
        val widgetTypeERef = GrammarUtil.getReference(assignment.getTerminal() as CrossReference)
        val QualifiedName prefixQName = model.getPrefixQName(context)
        val IScope scope = model.getScope(widgetTypeERef,context)
        //Filtering the scope to only propose widget types valid in the current context
        for (IEObjectDescription description : scope.allElements) {
            val qname = description.qualifiedName
            val String typeName = if ('item'.equals(description.EClass.name.toLowerCase)) {
                    'tab'
                } else {
                    description.EClass.name.toLowerCase
                }
            if (!(prefixQName != null && !qname.startsWith(prefixQName) && !typeName.equals("screen"))) {
                val displayString = qualifiedNameConverter.toString(qname.skipFirst(qname.segmentCount - 1))
                val proposal = (createCompletionProposal(displayString + " " + typeName, displayString + " " + typeName,
                    null, context) as ConfigurableCompletionProposal)
                proposal.setAdditionalData(ImportReplacementTextApplier::ADDITIONAL_DATA_QNAME, qname)
                proposal.setAdditionalProposalInfo(typeName)
                proposal.setTextApplier(importReplacementTextApplier)
                acceptor.accept(proposal)
            }
        }
    }
    
    
    /**
     * Return the Scope for the nearest Screen based on the offset of the cursor
     */
    def getScope(EObject model,EReference widgetTypeERef, ContentAssistContext context){
        val screenBeforeOffset = model.getScreenBeforeOffset(context)
        if (model.isSingleScreenSwitch || screenBeforeOffset==null) {
             scopeProvider.getScope(model, widgetTypeERef)
        } else {
             scopeProvider.getScope(screenBeforeOffset, widgetTypeERef)
        }
    }
    
    /**
     * Return the Qualified Name of the nearest Screen based on the offset of the cursor
     */
    def getPrefixQName(EObject model,ContentAssistContext context){
        //Based on the available screen switches within the scenario the scope is determined.
        val screenBeforeOffset = model.getScreenBeforeOffset(context)
        if (model.isSingleScreenSwitch || screenBeforeOffset==null) {
            model.widgetContainerOfNearestContext?.fullyQualifiedName
        } else {
            screenBeforeOffset.fullyQualifiedName
        } 
    }
    
    /**
     * True if there are more than one BToScreeSwitch objects in the scenario
     */
    def isSingleScreenSwitch(EObject model){
        if(model.getAllContentsOfType(BToScreenSwitch)==null){
            false
        }else{
            model.getAllContentsOfType(BToScreenSwitch).size < 2
        }
    }
    
    /**
     * Returns the last Screen referenced before the offset of the context
     */
    def getScreenBeforeOffset(EObject model,ContentAssistContext context){
        var Screen screen=null
        for (BToScreenSwitch screenSwitch : model.getAllContentsOfType(BToScreenSwitch)) {
                if (screenSwitch.screen !=null && context.offset>NodeModelUtils.getNode(screenSwitch).offset) {
                    screen=screenSwitch.screen
                }
            }
        return screen
    }
    
    /**
     * Returns true if the last screen before the offset has a table
     */
    def fromThePossible(EObject model, ContentAssistContext context){
          switch model {
            BScenario: if(model.getScreenBeforeOffset(context)?.widgets.filter(Table).size > 0||model.getScreenBeforeOffset(context)?.widgets.filter(Tree).size > 0||model.getScreenBeforeOffset(context)?.widgets.filter(Accordion).size > 0) return true
        }
    }

    /**
     * create a proposal for the name of a type (DSL has requirements for 
     * redundant type name mentioning of referenced wireframe widgets) 
     * 
     * @param widgetReference - the EReference to the widget, this will be used on the 
     * given {@code model} to compute the type name suggestion
     */
    def createTypeNameProposal(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor, EReference widgetReference) {
        val suggestedName = model.getReferencedNameSupportTypeName(widgetReference)
        if (suggestedName != null) {
            acceptor.accept(createCompletionProposal(suggestedName, context))
        }
    }

    /** 
     * For a given group, filters the keywords and joins them.
     * @param group the group to use for the proposal, example: 
     * myGrammarRuleAccess.getGroup()
     * 
     * @param withSpaceBetweenWords - set this to true if the keywords should be joined 
     * with a 'space'as separator, otherwise they will be just concatenated
     * 
     * @return the proposal, example: "I want to" for the grammar rule
     * 
     * MyGrammarDatatypeRule:
     * 'I' 'want' 'to'
     */
    def createKeywordProposal(Group group, ContentAssistContext context, ICompletionProposalAcceptor acceptor,
        boolean withSpaceBetweenWords) {
        if (group == null) {
            return null
        }
        val joinChar = if (withSpaceBetweenWords) {
                " "
            } else {
                ""
            }
        val proposalString = group.elements.filter(Keyword).map[value].join(joinChar) + " "
        acceptor.accept(createCompletionProposal(proposalString, proposalString, null, context))
    }

    def createKeywordProposal(Group group, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
        createKeywordProposal(group, context, acceptor, true)
    }

    override completeBFeaturePackage_Name(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        val packageName = model.completeBPackage_Name()
        acceptor.accept(createCompletionProposal(packageName,packageName, null, context))
        
    }
    
    /**
     * Proposes the root node of a tree widget
     */
    def proposeTreeRoot(String rawProposal,ContentAssistContext context, ICompletionProposalAcceptor acceptor){
        val proposal=if(rawProposal.indexOf("}")>0){rawProposal.substring(rawProposal.indexOf("}")+1)}else{rawProposal}
        acceptor.accept(createCompletionProposal('"'+proposal.trim+'"', proposal, null, context))
    }
    
    /**
     * Propose all treenodes underneath the given path in the tree
     * Consider the following tree where the number of '-' determines the level in the tree.
     * <br>
     * <br>Root A
     * <br>-Node B
     * <br>-Node C
     * <br>--Node D
     * <br>--Node E
     * <br>---Node F
     * <br>--Node G
     * <br>-Node H
     * <br>
     * 
     * <br>If the model is a NodeQName like '"Root A"'  then Node B, C, and H will be proposed
     * <br>If the model is a NodeQName like '"Root A" > "Node C"' then Node D, E, and G will be proposed
     * <br>If the model is a NodeQName like '"Root A" > "Node C > "Node E"' then Node F will be proposed
     * <br>If the model is a NodeQName like '"Root A" > "Node C > "Node E"> "Node F"' then no node will be proposed
     */
    def proposeTreeNode(EObject model,String treeStructure, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
        switch (model) {
            NodeQName: {
                val remainingText = newArrayList(treeStructure)
                model.findCurrentPositionInTree(remainingText)
                if (model.segment.size() > 0) {
                model.proposeChildren(remainingText,context,acceptor)                   
                }
              }
        }
    }
    /**
     * Based on the path included in the DSL the position in the underlying tree is retrieved.
     * This position is the basis for the context specific proposals
     */
    def findCurrentPositionInTree(NodeQName model,List<String> remainingText){
        model.segment.forEach [
            val value = if (it.getText != null &&
                    !it.getText.equals("")) {
                    it.getText
                } else if (it.param != null &&
                    !it.getParam.equals("")) {
                    it.param.name
                } else {
                    it.int
                }
            switch value {
                String: {
                    // Always written at the first position of the array
                    remainingText.add(0, remainingText.get(0).substring(remainingText.get(0).indexOf(value) + value.length + 1))
                }
            }
        ]
    }
    
    /**
     * Create a proposal for all children of the current Node
     */
    def proposeChildren(NodeQName model, List<String> remainingText, ContentAssistContext context, ICompletionProposalAcceptor acceptor ){
        var pattern = StringUtils.repeat("-",model.segment.size)
        val wrongpattern = pattern + "-"
        for (String s : remainingText.get(0).split("\\n")) {
            if (s.startsWith(wrongpattern)) {
                // To deep in tree
                println("ignore: " + s)
            } else if (s.startsWith(pattern)) {
                // The one we are looking for
                var proposal = s
                proposal =  if (proposal.indexOf("}") > 0) {proposal.substring(proposal.indexOf("}") + 1)} 
                            else {proposal.substring(proposal.indexOf(pattern) + pattern.length +1)}
                acceptor.accept(createCompletionProposal('"' + proposal.trim + '"', proposal,  null, context))
            }else if (pattern.length > 1 && s.startsWith(pattern.substring(0, pattern.length - 1))) {
              // Higher level one, so now we got all children visited
              return
            }
       }
    }
}
