/*
 * generated by Xtext
 */
package org.boomslang.dsl.feature.scoping

import com.google.inject.Inject
import com.wireframesketcher.model.Screen
import org.boomslang.dsl.feature.feature.BScenario
import org.boomslang.dsl.feature.feature.BWidgetWrapper
import org.boomslang.dsl.feature.feature.FeaturePackage
import org.boomslang.dsl.feature.services.WidgetTypeRefUtil
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.scoping.impl.FilteringScope
import com.wireframesketcher.model.WidgetContainer
import org.boomslang.wireframesketcher.model.xtext.IEObjectDescriptionUtil
import java.util.ArrayList
import org.boomslang.dsl.feature.feature.BToScreenSwitch
import org.eclipse.xtext.resource.IEObjectDescription
import com.wireframesketcher.model.Master
import org.boomslang.dsl.feature.feature.BTabPaneSelectTabAction
import org.boomslang.dsl.feature.feature.BTabAssertion
import org.boomslang.dsl.feature.feature.BCommandComponent
import com.wireframesketcher.model.TabbedPane
import org.eclipse.xtext.scoping.Scopes
import com.wireframesketcher.model.Item
import org.boomslang.dsl.feature.feature.BAssertionComponent

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class FeatureScopeProvider extends AbstractDeclarativeScopeProvider {

	@Inject extension WidgetTypeRefUtil
	
	@Inject extension IEObjectDescriptionUtil
	
	@Inject extension FeatureQualifiedNameProvider
	
	def IScope scope_BStringOrParam_param(EObject ctx, EReference ref) {
		allowParamOfParentScenario(ctx, ref)
	}
	
	def IScope scope_BIntOrParam_param(EObject ctx, EReference ref) {
		allowParamOfParentScenario(ctx, ref)
	}

	def IScope scope_BIntOrStringOrParam_param(EObject ctx, EReference ref) {
		allowParamOfParentScenario(ctx, ref)
	}

	def IScope scope_BWidgetWrapper_widget(BWidgetWrapper ctx, EReference ref) {
		allowElementsInItsBWidgetContainer(ctx, ref)
	}

	def IScope scope_BWidgetWrapper_widget(EObject ctx, EReference ref) {
		allowElementsInItsBWidgetContainer(ctx, ref)
	}


	def IScope scope_BComboWrapper_list(EObject ctx, EReference ref) {
		allowElementsInItsBWidgetContainer(ctx, ref)
	}
	
	def IScope scope_BTreeWrapper_tree(EObject ctx, EReference ref) {
		allowElementsInItsBWidgetContainer(ctx, ref)
	}
	
	def IScope scope_BTabbedPaneWrapper_tabbedPane(EObject ctx, EReference ref) {
		allowElementsInItsBWidgetContainer(ctx, ref,EcoreUtil2.getContainerOfType(ctx, BScenario).BToScreenSwitch.screen)
	}
	
	/**
	 * This method is used in the tab select
	 */
	def IScope scope_BTabItemWrapper_tabItem(BTabPaneSelectTabAction ctx, EReference ref) {
		val cmd = ctx.eContainer as BCommandComponent
		val tabbedPane = cmd.widget.widget as TabbedPane
		val tabItems = tabbedPane.items as Iterable<Item>
		val scope = Scopes.scopeFor(tabItems, [item|item.simpleName], IScope.NULLSCOPE)
		return scope
	}

	/**
	 * This method is used for tab assertion
	 */
	def IScope scope_BTabItemWrapper_tabItem(BTabAssertion ctx, EReference ref) {
		val cmd = ctx.eContainer as BAssertionComponent
		val tabbedPane = cmd.widget.widget as TabbedPane
		val tabItems = tabbedPane.items as Iterable<Item>
		val scope = Scopes.scopeFor(tabItems, [item|item.simpleName], IScope.NULLSCOPE)
		return scope
	}

	def IScope scope_BToScreenSwitch_componentScreen(BToScreenSwitch ctx, EReference ref) {
	    val originalScope = delegateGetScope(ctx, ref)
        val scope = new FilteringScope(originalScope,[
        	isComponent
        ])
        //debugScope(scope)
	    return scope
	}

	def IScope scope_BToScreenSwitch_screen(BToScreenSwitch ctx, EReference ref) {
        val componentScreen = ctx.componentScreen
	    val originalScope = delegateGetScope(ctx, ref)
        val scope = if (componentScreen != null) {
        	// component part (tab) of a component screen
	        new FilteringScope(originalScope,[
	        	isComponentPart && isComponentPartOf(componentScreen)
	        ])
        } else {
        	// not a component part (tab)
        	new FilteringScope(originalScope,[
	        	!isComponentPart
	        ])
        }        
        //debugScope(scope)
	    return scope
	}
	
	def EObject getEObject(IEObjectDescription description, EObject ctx) {
		val objectOrProxy = description.EObjectOrProxy
		val EObject eObject = if (objectOrProxy.eIsProxy) {
			EcoreUtil.resolve(objectOrProxy, ctx);
		} else {
			objectOrProxy
		}
		return eObject
	}
	
	def boolean isComponentPartOf(IEObjectDescription candidatePartDesc, Screen componentScreen) {
		val candidatePart = getEObject(candidatePartDesc, componentScreen) as Screen
		candidatePart.widgets.filter(Master).exists[screen == componentScreen]
	}
	
	def debugScope(IScope scope) {
		val scopeAllElements = scope.allElements
		println('Scope elements:\n' + scopeAllElements.join('\n')['- ' + name.toString])
	}


	def IScope scope_BToScreenSwitch_screen(EObject ctx, EReference ref) {
        val originalScope = delegateGetScope(ctx, ref)
        //if the referenced screen/widget is a "Part" of another component(e.g. tab screen as part of tabbedpane)
        //then the function isComponentPart returns true
        return new FilteringScope(originalScope,[!isComponentPart])
    }
    

	
	/**
	 * Returns all elements that are available in the WidgetContainer of the current widget. 
	 * 
	 */
	def IScope allowElementsInItsBWidgetContainer(EObject dslObject, EReference ref) {
		allowElementsInItsBWidgetContainer(dslObject,ref,dslObject.widgetContainerOfNearestContext)
	}

	def IScope allowElementsInItsBWidgetContainer(EObject dslObject, EReference ref, WidgetContainer allowedWidgetContainer) {
		val allowedWidgetContainers = newArrayList(allowedWidgetContainer)
		allowElementsInItsBWidgetContainer(dslObject,ref,allowedWidgetContainers)
	}
		
	/**
	 * Elements in the DSL may 
	 * 1) be contained inside of BWidgetContainers and 
	 * 2) reference wireframe model elements
	 * If that is the case, only wireframe model elements of the WidgetContainer of the BWidgetContainer are allowed.
	 * If the BWidgetContainer does not reference any WidgetContainer, the BWidgetContainer of the BWidgetContainer
	 * will be checked (e.g. a BPostCondition (a BWidgetContainer) is contained in BTestCode (also a BWidgetContainer).
	 * 
	 * This method filters the default scope containing wireframe model elements so that only model elements are allowed 
	 * that have the same WidgetContainer as the given dslObject.
	 * Same
	 * @param dslObject - an object in the DSL that is contained (directly or indirectly) in a BWidgetContainer
	 * @param ref - the dslObject's reference to a wireframe model element
	 */
	def IScope allowElementsInItsBWidgetContainer(EObject dslObject, EReference ref, ArrayList<WidgetContainer> allowedWidgetContainer) {
		val originalScope = delegateGetScope(dslObject, ref)

		//val allowedWidgetContainer = dslObject.widgetContainerOfNearestContext
		if (allowedWidgetContainer == null) {
			return IScope.NULLSCOPE
		}

		return new FilteringScope(originalScope,
			[ candidate |
				val objectOrProxy = candidate.EObjectOrProxy
				val EObject candidateEObject = if (objectOrProxy.eIsProxy) {
						EcoreUtil.resolve(objectOrProxy, dslObject);
					} else {
						objectOrProxy
					}
				val candidateContainer = EcoreUtil2.getContainerOfType(candidateEObject, Screen)
				return  allowedWidgetContainer.contains(candidateContainer)
			])
	}

	/**
	 * In a scenario (e.g. in commands or assertions), params may be referenced. Only params
	 * of the scenario should be referenceable, and not params of other scenarios. 
	 * 
	 * @return a scope containing all parameters of a scenario that is the parent of the given {@code dslObject}
	 * 
	 * @param dslObject - an object in the DSL that is contained (directly or indirectly) in a BWidgetContainer
	 * @param ref - the dslObject's reference to a wireframe model element
	 */
	def IScope allowParamOfParentScenario(EObject dslObject, EReference ref) {
		val originalScope = delegateGetScope(dslObject, ref)

		val parentScenario = EcoreUtil2.getContainerOfType(dslObject, BScenario)
		if (parentScenario == null) {
			return IScope.NULLSCOPE
		}
		return new FilteringScope(originalScope,
			[ candidate |
				val objectOrProxy = candidate.EObjectOrProxy
				val EObject candidateEObject = if (objectOrProxy.eIsProxy) {
						EcoreUtil.resolve(objectOrProxy, dslObject);
					} else {
						objectOrProxy
					}
				return candidate.EClass == FeaturePackage.Literals.BPARAMETER &&
					candidateEObject.eContainer() == parentScenario
			])

	}

}