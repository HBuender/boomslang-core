/*
 * generated by Xtext
 */
package org.boomslang.dsl.feature.validation

import org.boomslang.core.validation.PackageFolderStructureValidator
import org.boomslang.dsl.feature.feature.BScenario
import org.boomslang.dsl.feature.feature.FeaturePackage
import com.google.inject.Inject
import java.util.List
import org.eclipse.xtext.resource.IContainer
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.ComposedChecks

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@ComposedChecks(validators=#[
	AssertionValidator,
	FilenameValidator,
	PackageFolderStructureValidator,
	TypeCorrespondsToRefValidator
])
class FeatureValidator extends AbstractFeatureValidator {

    @Inject
    ResourceDescriptionsProvider resourceDescriptionsProvider;

    @Inject
    IContainer.Manager containerManager;
     
  
    
	public static String SCENARIO_DEPENDENCY_LOOP = "SCENARIO_DEPENDENCY_LOOP"

	public static String REFERENCED_PARAMETERIZED_SCENARIO = "REFERENCED_PARAMETERIZED_SCENARIO"
	
	public static val NO_MAPPING_FOR_WIDGET = "NO_MAPPING_FOR_WIDGET"
	
	public static val SCENARIO_NAME_VALID = "SCENARIO_NAME_VALID"
	

	/**
	 * Loop protection when one scenario references another scenario
	 */
	@Check
	def void checkBScenarioDependsOnLoop(BScenario bScenario) {
		checkBScenarioDependsOnLoop(bScenario, newArrayList(bScenario))
	}

	/**
	 * checks
	 * 1) that there are no loops in scenarios referencing other scenarios
	 * 2) that all referenced scenarios have no parameters, because
	 * it is not yet defined what it means when scenario A depends on 
	 * a parameterized scenario B? 
	 * should A be executed multiple times? what if A is also parameterized?
	 */
	def void checkBScenarioDependsOnLoop(BScenario bScenario, List<BScenario> scenarioChain) {
		val nextScenarioInChain = bScenario.preScenario
		if (nextScenarioInChain == null) {
			return
		}
		if (!nextScenarioInChain.params.nullOrEmpty || nextScenarioInChain.dataProvider != null) {
			error(
				'''Only unparameterized scenarios may be used as dependencies, but �nextScenarioInChain.name� is parameterized (chain: �scenarioChain.
					map[name].join(" -> ")� -> �nextScenarioInChain.name�)''', scenarioChain.head,
				FeaturePackage.Literals.BSCENARIO__PRE_SCENARIO, REFERENCED_PARAMETERIZED_SCENARIO)
			return
		}
		if (scenarioChain.contains(nextScenarioInChain)) {
			error(
				'''Recursive dependencies, the chain is: �scenarioChain.map[name].join(" -> ")� -> �scenarioChain.head.
					name�''', scenarioChain.head, FeaturePackage.Literals.BSCENARIO__PRE_SCENARIO, SCENARIO_DEPENDENCY_LOOP)
			return
		}
		scenarioChain.add(nextScenarioInChain)
		checkBScenarioDependsOnLoop(nextScenarioInChain, scenarioChain)
	}
	
	/**
	 * Checks if every widget in the feature description is mapped in a mapping file. Currently under the assumption that there is exactly one
	 * Mapping file per screen.
	 */
//	@Check
//    def void checkUsedWidgetMapped(BWidgetWrapper wrapper) {
//        val index = resourceDescriptionsProvider.getResourceDescriptions(wrapper.eResource());
//        val resourceDescription = index.getResourceDescription(wrapper.eResource().getURI());
//        for (IContainer visibleContainer : containerManager.getVisibleContainers(resourceDescription, index)) {
//            for (IEObjectDescription od : visibleContainer.getExportedObjectsByType(
//                MappingPackage.Literals.BMAPPING_PACKAGE)) {
//                val bMappingPackage = wrapper.eResource().getResourceSet().getEObject(od.getEObjectURI(), true) as BMappingPackage;
//                if(bMappingPackage.BMapping.screen.equals(wrapper.widget.container as Screen)){
//                    if(bMappingPackage.BMapping.BWidgetMapping.findFirst[it.widget.equals(wrapper.widget)]==null){
//                        error("Widget "+wrapper.widget.name+" not mapped.",wrapper,FeaturePackage.Literals.BWIDGET_WRAPPER__WIDGET,NO_MAPPING_FOR_WIDGET, wrapper.widget.name+";"+wrapper.widget.type)
//                    }
//                }        
//            } 
//        }
//    }
//    
    @Check
    def void checkScenarioNameConstraint(BScenario bScenario){
        if (!bScenario.name.matches("\\\"[a-zA-Z0-9\\s]*\\\"")){
            warning("Scenario name "+bScenario.name+" contains invalid characters. Only characters, numbers, and whitespaces are allowed",bScenario,FeaturePackage.Literals.BSCENARIO__NAME,SCENARIO_NAME_VALID)
         }
    }
} 